# Purpose: generate a "mission area polygon" that represents the area considered "survey area"
# One way to do this is to use the RGB photos taken automatically by MapPilot only within the
# survey grid (and one on the launch pad at the start of each flight) to designate the 
# survey area.

# Another way would be to use the flight logs themselves as generated by the aircraft. 
# These are automatically generated by MapPilot, and some companies offer a paid service to 
# collate these logs and provide meaningful information about your fleet of aircraft and 
# your batteries (e.g., AirData). I don't know whether you need an AirData account to get
# the .csv files from MapPilot.
# It'd be awesome if there were an open source way to get these logs and use them!

# Load libraries
library(sf)
library(tidyverse)
library(purrr)
library(raster)

site_name <- "niwo_017"
flight_datetime <- "2019-10-09"

agl_of_mission_m <- 100

dem <- raster::raster("data/data_raw/N40W106.hgt")

flight_logs_list <- 
  list.files(paste0("drone/L0/flight-logs/", site_name), full.names = TRUE) %>% 
  purrr::map(read_csv) %>% 
  purrr::map(.f = function(x) {
    x %>% 
      sf::st_as_sf(coords = c("Longitude", "Latitude")) %>%
      sf::st_set_crs(4326)
  })

  # # assume the first row of each log file is the location of the takeoff point
  # # All altitude calculations are relative to this point, so getting the
  # # elevation of this point from the DEM tells us the offset
  # takeoff_points <-
  #   purrr::map(flight_logs_list, .f = function(x) {
  #     x %>% 
  #       dplyr::slice(1)
  #   })
  x <- flight_logs_list[[1]]
  # filter the spatial flight log to just the rows where images incremented
  # and the drone is in a "flying" condition
  photo_points_list <-
    purrr::map(flight_logs_list, .f = function(x) {
      photo_points <-
        x %>% 
        dplyr::filter(Images > lag(Images))
      
      takeoff_point <- x[which.min(x$Time), ]
      photo_points <- rbind(takeoff_point, photo_points)
    })
  
  # Iterate over the list elements representing the photo points for each flight
  # and the take off point for each flight to calculate the elevation for each
  # photo point (on the ground) and the agl (above ground level) measure for
  # each photo point (by taking the ground elevation, the takeoff elevation, and
  # the relative altitude offset from the takeoff elevation into account)
  # Note: the agl should be fairly consistent across the whole mission.
  photo_points <- 
    purrr::map(photo_points_list, .f = function(x) {
      
      takeoff_point <- x[which.min(x$Time), ]
      takeoff_elev <- raster::extract(dem, takeoff_point, method = "bilinear")
      
      x %>% 
        dplyr::mutate(ground_elev_under_photo = raster::extract(dem, ., method = "bilinear")) %>% 
        dplyr::mutate(agl = `Altitude (m)` + takeoff_elev - ground_elev_under_photo) %>%
        dplyr::filter(agl > (agl_of_mission_m / 2))
    }) %>% 
    do.call(rbind, .)
   
  # create a vector object representing the convex hull of the photopoints
  site_bounds <- 
    photo_points %>% 
    st_union() %>% 
    st_convex_hull() %>% 
    st_as_sf()
  
  # Grab the site DEM with a 3 arc second buffer
  site_dem <- raster::crop(x = dem, y = st_buffer(site_bounds, 3 / 60 / 60), snap = "out")
  
  dir.create(paste0("drone/L1/survey-extent/", site_name), recursive = TRUE)
  
  sf::st_write(obj = photo_points, dsn = paste0("drone/L1/survey-extent/", site_name, "/", flight_datetime, "_rgb-photo-points.geoJSON"), delete_dsn = TRUE)
  sf::st_write(obj = site_bounds, dsn = paste0("drone/L1/survey-extent/", site_name, "/", flight_datetime, "_site-bounds.geoJSON"), delete_dsn = TRUE)
  raster::writeRaster(x = site_dem, filename = paste0("drone/L1/survey-extent/", site_name, "/", flight_datetime, "_site-dem.tiff"), overwrite = TRUE)
  