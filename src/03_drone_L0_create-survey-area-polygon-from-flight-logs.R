# Purpose: generate a "mission area polygon" that represents the area considered "survey area"
# One way to do this is to use the RGB photos taken automatically by MapPilot only within the
# survey grid (and one on the launch pad at the start of each flight) to designate the 
# survey area.

# Another way would be to use the flight logs themselves as generated by the aircraft. 
# These are automatically generated by MapPilot, and some companies offer a paid service to 
# collate these logs and provide meaningful information about your fleet of aircraft and 
# your batteries (e.g., AirData). I don't know whether you need an AirData account to get
# the .csv files from MapPilot.
# It'd be awesome if there were an open source way to get these logs and use them!

# Load libraries
library(sf)
library(tidyverse)
library(purrr)
library(raster)

site_name <- "niwo_017"
flight_datetime <- "2019-10-09"

agl_of_mission_m <- 100


# Digital Elevation Model data come from the SRTM mission and the 1 arcsecond global product
# https://lpdaac.usgs.gov/products/srtmgl1v003/
dem <- raster::raster("data/data_raw/N40W106.hgt")

flight_logs_list <- 
  list.files(paste0("drone/L0/flight-logs/", site_name), full.names = TRUE) %>% 
  purrr::map(read_csv) %>% 
  purrr::map(.f = function(x) {
    x %>% 
      sf::st_as_sf(coords = c("Longitude", "Latitude")) %>%
      sf::st_set_crs(4326)
  })

  # # assume the first row of each log file is the location of the takeoff point
  # # All altitude calculations are relative to this point, so getting the
  # # elevation of this point from the DEM tells us the offset
  takeoff_points <-
    purrr::map(flight_logs_list, .f = function(x) {
      x %>%
        dplyr::slice(1)
    })

  # filter the spatial flight log to just the rows where images incremented
  # and the drone is in a "flying" condition
  photo_points_list <-
    purrr::map(flight_logs_list, .f = function(x) {
      photo_points <-
        x %>% 
        dplyr::filter(Images > lag(Images))
      
      takeoff_point <- x[which.min(x$Time), ]
      photo_points <- rbind(takeoff_point, photo_points)
    })
  
  # Iterate over the list elements representing the photo points for each flight
  # and the take off point for each flight to calculate the elevation for each
  # photo point (on the ground) and the agl (above ground level) measure for
  # each photo point (by taking the ground elevation, the takeoff elevation, and
  # the relative altitude offset from the takeoff elevation into account)
  # Note: the agl should be fairly consistent across the whole mission.
  photo_points <- 
    purrr::map(photo_points_list, .f = function(x) {
      
      takeoff_point <- x[which.min(x$Time), ]
      takeoff_elev <- raster::extract(dem, takeoff_point, method = "bilinear")
      
      x %>% 
        dplyr::mutate(ground_elev_under_photo = raster::extract(dem, ., method = "bilinear")) %>% 
        dplyr::mutate(agl = `Altitude (m)` + takeoff_elev - ground_elev_under_photo) %>%
        dplyr::filter(agl > (agl_of_mission_m / 2))
    }) %>% 
    do.call(rbind, .)
   
  # create a vector object representing the convex hull of the photopoints
  site_bounds <- 
    photo_points %>% 
    st_union() %>% 
    st_convex_hull()
  
  # Grab the site DEM with a 3 arc second buffer
  site_dem <- raster::crop(x = dem, y = as(st_buffer(site_bounds, 3 / 60 / 60), "Spatial"), snap = "out")
  
  if(!dir.exists("drone/L0/mission-footprint/niwo_017/2019-10-09")) {
    dir.create("drone/L0/mission-footprint/niwo_017/2019-10-09", recursive = TRUE)
  }
  
  if (!file.exists("drone/L0/mission-footprint/niwo_017/2019-10-09/niwo_017_2019-10-09_photo-points.geoJSON")) {
    sf::st_write(obj = photo_points, dsn = "drone/L0/mission-footprint/niwo_017/2019-10-09/niwo_017_2019-10-09_photo-points.geoJSON", delete_dsn = TRUE)
  }
  
  if (!file.exists("drone/L0/mission-footprint/niwo_017/2019-10-09/niwo_017_2019-10-09_site-bounds.geoJSON")) {
    sf::st_write(obj = site_bounds, dsn = "drone/L0/mission-footprint/niwo_017/2019-10-09/niwo_017_2019-10-09_site-bounds.geoJSON", delete_dsn = TRUE)
  }
  
  if (!file.exists("drone/L0/mission-footprint/niwo_017/2019-10-09/niwo_017_2019-10-09_srtm30m.tif")) {
    raster::writeRaster(site_dem, filename = "drone/L0/mission-footprint/niwo_017/2019-10-09/niwo_017_2019-10-09_srtm30m.tif", overwrite = TRUE)
  }
  
  # also create a bounding box that is just around the field data (with a little buffer)
  niwo_017 <- 
    st_read("data/data_output/niwo_017_gcp-locations.geoJSON") 
  
  niwo_017_local_crs <-
    paste0("32", 
           ifelse(stringr::str_detect(string = unique(niwo_017$utmZone), pattern = "N"), yes = "6", no = "7"), 
           stringr::str_extract(unique(niwo_017$utmZone), pattern = "[0-9]+")) %>% 
    as.numeric()
  
  constrained_site_bounds <-
    niwo_017 %>% 
    sf::st_drop_geometry() %>% 
    st_as_sf(coords = c("easting", "northing"), crs = niwo_017_local_crs) %>% 
    st_union() %>% 
    st_convex_hull() %>% 
    st_buffer(dist = 20, joinStyle = "MITRE", mitreLimit = 5) %>% 
    st_transform(4326)
  
  if (!file.exists("drone/L0/mission-footprint/niwo_017/2019-10-09/niwo_017_2019-10-09_constrained-site-bounds.geoJSON")) {
    sf::st_write(obj = constrained_site_bounds, dsn = "drone/L0/mission-footprint/niwo_017/2019-10-09/niwo_017_2019-10-09_constrained-site-bounds.geoJSON", delete_dsn = TRUE)
  }